# Network Programming Assignment: Request–Reply Messaging App

## Purpose
The purpose of this assignment is to become familiar with **network programming**. You will develop a **distributed messaging system** that uses a simple **request–reply protocol**.

Clients send a **Request** to the Server, and the Server replies with a **Response**; then the connection is terminated.

You may implement the system using either:
- **Sockets** (Sockets / I/O streams / Threads), or
- **RMI** (Remote Method Invocation)

## System Overview
In this system, different users can create **accounts** and send **messages** to each other, while the server manages them.

The system must include:
1. A **server program** capable of handling **multiple client requests concurrently**.
2. **client programs**, each capable of sending requests to the server.

---

## Core Components

### A. Message
Every message that is sent, received, or stored on the server must have the following fields:

| Field | Type | Description |
|---|---|---|
| `isRead` | `boolean` | Indicates whether the message has already been read. |
| `sender` | `String` | The sender of the message. |
| `receiver` | `String` | The receiver of the message. |
| `body` | `String` | The message text. |

You may add any additional fields you consider necessary for the implementation.

### B. Account
Each user account is stored on the server in the following form:

| Field | Type | Description |
|---|---|---|
| `username` | `String` | The username. It consists only of **alphanumeric** characters and the special character **"_"**. |
| `authToken` | `int` | A unique identification number for the user (generated by the server and considered private/secret). |
| `messageBox` | `List<Message>` | The user’s mailbox, which is a list of `Message` objects. |

You may add any additional fields you consider necessary for the implementation.

### C. MessagingClient
The client program implements communication between the user and the server.

It must:
- accept input from the user and send it to the server, while also
- receiving data from the server and printing it appropriately to the user.

### D. MessagingServer
The server runs continuously as a service, **listening** for incoming client requests.

Each incoming request must be assigned to a **separate thread** (you may use Threads or RMI), so that multiple requests can be served concurrently.

The server must maintain a list of user accounts (`Account`) so that registered users, their auth tokens, and their mailboxes are preserved while the programs are running.

Finally, the server must implement the methods required for user communication.

---

## Operations
The delivered programs must support **all** operations described below.

**Important:** Output must be **exactly** in the format shown in the scenario tables.

---

## Server Execution
Run the server as:

```bash
java server <port number>
```

Where `<port number>` is the port on which the server listens for requests.

---

## Client Execution
Run the client as:

```bash
java client <ip> <port number> <FN_ID> <args>
```

Where:
- `ip`: Server IP address
- `port number`: Server port
- `FN_ID`: the function identifier to execute
- `args`: function parameters

---

## Create Account (FN_ID: 1)

```bash
java client <ip> <port number> 1 <username>
```

Creates an account using the given username.  
Returns a unique token (`authToken`) that will be used for authentication in subsequent requests.

### Scenarios

| Scenario | Output |
|---|---|
| Success | `<integer>` |
| User already exists | `Sorry, the user already exists` |
| Invalid username format | `Invalid Username` |

**Example (Success)**
```bash
$> java client localhost 5000 1 tester
1024
```
In the example above, the user `tester` will use authToken `1024` from now on.

**Example (User already exists)**
```bash
$> java client localhost 5000 1 tester
Sorry, the user already exists
```

**Example (Invalid username)**
```bash
$> java client localhost 5000 1 inv@-lid
Invalid Username
```

---

## Show Accounts (FN_ID: 2)

```bash
java client <ip> <port number> 2 <authToken>
```

Shows a list of all accounts in the system.

### Output format (always)
```
1. <username_1>
2. <username_2>
...
n. <username_n>
```

**Example**
```bash
$> java client localhost 5000 2 1024
1. demo
2. raven_13
3. dr4g0n_sl4y3r
```

---

## Send Message (FN_ID: 3)

```bash
java client <ip> <port number> 3 <authToken> <recipient> <message_body>
```

Sends `<message_body>` to the account with username `<recipient>`.

### Scenarios

| Scenario | Output |
|---|---|
| Successful send | `OK` |
| Recipient does not exist | `User does not exist` |

**Example (Success)**
```bash
$> java client localhost 5000 3 1024 tester "HELLO WORLD"
OK
```

**Example (Recipient does not exist)**
```bash
$> java client localhost 5000 3 1024 friend "HELLO WORLD"
User does not exist
```

---

## Show Inbox (FN_ID: 4)

```bash
java client <ip> <port number> 4 <authToken>
```

Displays the list of all messages for a specific user (messages in the user’s `messageBox`).

Notes:
- The message list exists only while the programs are running.
- No file usage is required.
- The mailbox must be created dynamically.

### Required output format
```
<message_id_1>. from: <username_x>*?
<message_id_2>. from: <username_y>*?
...
<message_id_n>. from: <username_z>*?
```

The asterisk `*` is shown **only if the message has not been read**.

**Example**
```bash
$> java client localhost 5000 4 1024
27. from: raven_13*
43. from: demo*
55. from: raven_13*
58. from: raven_13*
67. from: dr4g0n_sl4y3r
```
In the example above, the message from `dr4g0n_sl4y3r` has already been read.

---

## ReadMessage (FN_ID: 5)

```bash
java client <ip> <port number> 5 <authToken> <message_id>
```

Displays the content of the message with id `<message_id>`, and then marks it as read.

### Scenarios

| Scenario | Output |
|---|---|
| Success | `(<sender>) <message>` |
| Message ID does not exist | `Message ID does not exist` |

**Example (Success)**
```bash
$> java client localhost 5000 5 1024 43
(demo) Hello World
```

**Example (Message ID does not exist)**
```bash
$> java client localhost 5000 5 1024 1111
Message ID does not exist
```

---

## DeleteMessage (FN_ID: 6)

```bash
java client <ip> <port number> 6 <authToken> <message_id>
```

Deletes the message with id `<message_id>`.

### Scenarios

| Scenario | Output |
|---|---|
| Success | `OK` |
| Message does not exist | `Message does not exist` |

**Example (Success)**
```bash
$> java client localhost 5000 6 1024 43
OK
```

**Example (Message does not exist)**
```bash
$> java client localhost 5000 6 1024 1111
Message does not exist
```

---

## Auth Token
Since the communication protocol does not keep user state per session, you must ensure that:
- no user can read another user’s data
- no user can send messages as another user

Therefore, the **authToken** must be used in every request. The server must associate each authToken with an `Account` (at account creation time).

If an invalid authToken is provided (i.e., it does not match any user), **all functions must return**:

```
Invalid Auth Token
```

---

## Deliverables
Submit a `.zip` file using Latin characters with the following format:

```
<aem>_<name>_<surname>.zip
```

Example:
```
1243_petros_riginos.zip
```

The zip must contain:

- `src/` : Source code files
- `jars/`
  - `Client.jar` : Executable Client jar
  - `Server.jar` : Executable Server jar
- `README.md` : Briefly describe the classes you implemented and any assumptions you made

**Important:** Submit strictly in the correct format and folder structure.  
It is recommended to run your programs as jar files to verify correct operation before submitting:

```bash
java -jar Server.jar 5000
java -jar Client.jar localhost 5000 1 demousername
```

---

## Creating an Executable JAR (IntelliJ)

### Step 1
Follow:

`File > Project Structure > Project Settings > Artifacts > Click green plus sign > Jar > From modules with dependencies...`

### Step 2
If your project contains **two files with a `main` method**, you must create **two `.jar` files** (one for `Client` and one for `Server`). Repeat the artifact creation process for both.

For each artifact, set the correct name (e.g., `Client` or `Server`). By default, IntelliJ may assign the same name as the project—rename it so you can clearly identify which output folder corresponds to each jar.

After this, two XML files should appear in your project tree (one for each artifact).

### Step 3
Build the executable jars:

`Build > Build Artifacts... > All Artifacts > (Client.jar / Server.jar) > Build`

IntelliJ will store the generated jars in the project’s `out` folder, typically inside two subfolders (e.g., `Client_jar` and `Server_jar`).

Because IntelliJ may generate both jars with the same default filename (e.g., `<projectName>.jar`), rename them (right click → Refactor → Rename → Proceed anyway) to:

- `Client.jar`
- `Server.jar`

before placing them in the `jars/` folder for submission.
